---
title: "Deep Research"
description: "Lessons learned from recreating a deep-research agent on ADP"
enableComments: true
author: "Steven Lynn"
github_username: "stvlynn"
x_username: "Stv_Lynn"
demo_url: https://adp-deepresearch.vercel.app
---

⬇️ Preview

<Callout title="How to use">Enter a research topic—such as "Tencent Cloud AI"—and the workflow generates a structured report.</Callout>

<iframe
  src="https://adp-deepresearch.vercel.app/" 
  style={{ width: '100%', height: '600px', border: '0' }}
  allow="clipboard-write *; microphone; camera"
></iframe>

## Introduction

I recently built a deep-research agent on the Tencent Cloud Agent Development Platform (ADP). The project reshaped how I think about low-code workflow orchestration, so I’m sharing the process in case it helps anyone exploring AI agent development.

## Project Background

Deep research goes far beyond keyword lookup. It breaks a topic into multiple dimensions, gathers information step by step, and composes a structured research report. That level of complexity is a perfect match for a workflow-driven approach.

## Architecture Overview

### Workflow hierarchy

The solution relies on nested workflows, each with a clear responsibility:

<Mermaid
  chart={`
graph TD
    subgraph "Main Workflow: Deep Research"
        A1[Start] --> A2[Capture topic]
        A2 --> A3[Show topic confirmation]
        A3 --> A4[Generate four subtopics]
        A4 --> A5[Display subtopics]
        A5 --> A6{Proceed?}
        A6 -->|Confirm| A7[Batch-call research runner]
        A6 -->|Cancel| A8[End]
        A7 --> A9[Show progress]
        A9 --> A10[Aggregate final report]
        A10 --> A11[Render report]
        A11 --> A12{Generate PDF?}
        A12 -->|Yes| A13[Invoke PDF workflow]
        A12 -->|No| A14[End]
    end
    
    A7 -.->|Batch trigger| B1
    A13 -.->|Workflow call| C1
    
    subgraph "Level 2 Workflow: Research Runner"
        B1[Receive topic + subtopic] --> B2[Draft research steps]
        B2 --> B3[Iterate over steps]
        B3 --> B4[Call step workflow]
        B4 --> B5[Summarize subtopic report]
        B5 --> B6[Return to main flow]
    end
    
    subgraph "Level 2 Workflow: PDF Generator"
        C1[Receive content] --> C2[Render HTML5]
        C2 --> C3[Deploy to EdgeOne]
        C3 --> C4[Convert to PDF]
        C4 --> C5[Extract URL]
        C5 --> C6[Return link]
    end
    
    B4 -.->|Loop| D1
    
    subgraph "Level 3 Workflow: Step Executor"
        D1[Receive step] --> D2{Tool router}
        D2 -->|Search engine| D3[Build keywords]
        D2 -->|ArXiv| D4[Build ArXiv query]
        D3 --> D5[Batch keyword search]
        D4 --> D6[Batch paper search]
        D5 --> D7[Aggregate variables]
        D6 --> D7
        D7 --> D8[Write step report]
    end
    
    D5 -.->|Batch| E1
    D6 -.->|Batch| F1
    
    subgraph "Level 3 Workflow: Keyword Search"
        E1[Hunyuan AI search] --> E2[Return search results]
    end
    
    subgraph "Level 3 Workflow: Paper Search"
        F1[ArXiv API search] --> F2[Return paper list]
    end
    
    style A1 fill:#ff6666
    style A8 fill:#ff6666
    style A14 fill:#ff6666
    
    classDef mainFlow fill:#fff4e6,stroke:#ff9800,stroke-width:2px
    classDef subFlow fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
    classDef baseFlow fill:#f1f8e9,stroke:#689f38,stroke-width:2px
    classDef decision fill:#fff9c4,stroke:#fbc02d,stroke-width:2px
    
    class A1,A2,A3,A4,A5,A7,A9,A10,A11,A13 mainFlow
    class B1,B2,B3,B4,B5,B6,C1,C2,C3,C4,C5,C6 subFlow
    class D1,D3,D4,D5,D6,D7,D8,E1,E2,F1,F2 baseFlow
    class A6,A12,D2 decision
    `}
    />

## Core Flow Implementation

### 1. Topic breakdown and subtopic generation

After the user submits a topic, the workflow proceeds as follows:

```
Input topic -> Topic confirmation -> Generate four subtopics -> Subtopic confirmation
```

The key is to produce exploratory subtopics instead of blunt keyword permutations. For example, a study on "Artificial Intelligence" might yield:
- Current state and trends
- Real-world application cases
- Ethics and societal impact
- Future challenges and opportunities

**Topic collection**

| Parameter | Type | Description |
| --- | --- | --- |
| researchTopic | string | One-sentence description of the target topic |

![Topic capture form](https://s2.loli.net/2025/09/25/zR3kYl2I9hLXuTM.png)

**Subtopic collection**

| Parameter | Type | Description |
| --- | --- | --- |
| researchSubtopics | array[string] | Four subtopics. Each entry includes the original topic so the phrasing remains complete. |

![Subtopic capture form](https://s2.loli.net/2025/09/26/cX7obxeC2IFpmZq.png)

### 2. Parallel batch execution

<Mermaid
  chart="
graph LR;
    A[Subtopic list] --> B[Batch node];
    B --> C1[Subtopic #1 research];
    B --> C2[Subtopic #2 research];
    B --> C3[Subtopic #3 research];
    C1 --> D[Aggregate results];
    C2 --> D;
    C3 --> D;"
/>

The batch node runs subtopic research in parallel with a concurrency of three—a balance between throughput and API rate limits.

![Batch configuration](https://s2.loli.net/2025/09/26/JloqRGFp4Si2rfO.png)

### 3. Intelligent tool routing

When a step executes, the workflow selects the most suitable tool:

<Mermaid
  chart="
graph TD;
    A[Research step] --> B{Route tool};
    B -->|Academic| C[ArXiv paper search];
    B -->|General info| D[Hunyuan AI search];
    B -->|Fallback| E[Generic search];
    C --> F[Generate keywords];
    D --> F;
    E --> F;
    F --> G[Batch queries];
    G --> H[Aggregate results];"
/>

Dynamic routing ensures each information need leverages the right channel.

![Tool routing screenshot](https://s2.loli.net/2025/09/26/ZNGPaXy1p3xRAfz.png)

## Key Technical Highlights

### 1. Model selection strategy

Choosing specialized models for each task keeps quality high while controlling cost:

| Task | Model | Rationale |
| --- | --- | --- |
| Subtopic generation | DeepSeek V3 | Strong creativity and deep comprehension |
| Step planning | CS-Normal-70B | Logical, reliable, cost-effective |
| Final synthesis | DeepSeek R1 | High-quality holistic writing |
| Tool routing | Hunyuan model | Fast and accurate recognition |

### 2. Variable aggregation tricks

Variable aggregation makes it easy to merge results from multiple branches:

```javascript
// Aggregation sample
{
  "result": [searchResults, paperResults],
  "keyword": [searchKeywords, arxivKeywords]
}
```

![Aggregation config](https://s2.loli.net/2025/09/26/lZexcCS6Ujd98TX.png)

### 3. UX refinements

#### Progress messaging

Key stages display reassuring status updates:
- "Generating research steps for {topic}..."
- "Compiling the final report—this takes about one minute..."

#### Confirmation gates

Long-running actions include a confirmation step that:
- Shows the estimated execution time
- Lets users cancel before resources are consumed

![Confirmation screen](https://s2.loli.net/2025/09/26/vgVkEYX2ze9P6hW.png)

## Output Innovations

### PDF delivery workflow

Beyond plain text, the workflow exports polished PDFs:

<Mermaid
  chart="
graph LR;
    A[Markdown report] --> B[HTML5 renderer];
    B --> C[Deploy to EdgeOne];
    C --> D[Online preview URL];
    D --> E[PDF conversion];
    E --> F[PDF download link];"
/>

EdgeOne’s static hosting powers instant sharing of the finished report.

![PDF pipeline](https://s2.loli.net/2025/09/26/48AujbOWqYamkfC.png)

## Summary and Next Steps

Potential areas to explore next:
1. **Knowledge graph enrichment** to map relationships between research themes.
2. **Multimodal inputs** by incorporating images, video, or audio analysis.
3. **Collaborative research** so teams can co-create reports in real time.
4. **Incremental updates** that let users append fresh findings to existing work.

---

I hope this walkthrough sparks ideas for your own AI agent experiments. Low code does not mean low capability—the magic lies in thoughtful orchestration. If you run into challenges, drop a comment and let’s compare notes.
